auth.py
from datetime import datetime, timedelta
from typing import Optional
from jose import JWTError, jwt
from passlib.context import CryptContext
from app.core.config import settings

# ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø±Ù…Ø²Ù†Ú¯Ø§Ø±ÛŒ
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """
    Ø¨Ø±Ø±Ø³ÛŒ ØªØ·Ø§Ø¨Ù‚ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø³Ø§Ø¯Ù‡ Ø¨Ø§ Ù†Ø³Ø®Ù‡ Ù‡Ø´ Ø´Ø¯Ù‡
    
    Args:
        plain_password: Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± ÙˆØ±ÙˆØ¯ÛŒ Ú©Ø§Ø±Ø¨Ø±
        hashed_password: Ø±Ù…Ø² Ù‡Ø´ Ø´Ø¯Ù‡ Ø¯Ø± Ø¯ÛŒØªØ§Ø¨ÛŒØ³
    
    Returns:
        bool: True Ø§Ú¯Ø± Ø±Ù…Ø²Ù‡Ø§ Ù…Ø·Ø§Ø¨Ù‚Øª Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ù†Ø¯
    """
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    """
    ØªÙˆÙ„ÛŒØ¯ Ù‡Ø´ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ±
    
    Args:
        password: Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø®Ø§Ù…
    
    Returns:
        str: Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ù‡Ø´ Ø´Ø¯Ù‡
    """
    return pwd_context.hash(password)

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    """
    Ø§ÛŒØ¬Ø§Ø¯ ØªÙˆÚ©Ù† Ø¯Ø³ØªØ±Ø³ÛŒ JWT
    
    Args:
        data: Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± Ø¨Ø±Ø§ÛŒ Ù‚Ø±Ø§Ø±Ú¯ÛŒØ±ÛŒ Ø¯Ø± ØªÙˆÚ©Ù†
        expires_delta: Ù…Ø¯Øª Ø²Ù…Ø§Ù† Ø§Ù†Ù‚Ø¶Ø§ÛŒ ØªÙˆÚ©Ù†
    
    Returns:
        str: ØªÙˆÚ©Ù† Ø¯Ø³ØªØ±Ø³ÛŒ Ø±Ù…Ø²Ù†Ú¯Ø§Ø±ÛŒ Ø´Ø¯Ù‡
    """
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    return jwt.encode(
        to_encode,
        settings.SECRET_KEY.get_secret_value(),
        algorithm=settings.JWT_ALGORITHM
    )

def decode_token(token: str) -> dict:
    """
    Ø±Ù…Ø²Ú¯Ø´Ø§ÛŒÛŒ ØªÙˆÚ©Ù† JWT
    
    Args:
        token: ØªÙˆÚ©Ù† Ø¯Ø±ÛŒØ§ÙØªÛŒ
    
    Returns:
        dict: Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¯Ø§Ø®Ù„ ØªÙˆÚ©Ù†
        
    Raises:
        JWTError: Ø§Ú¯Ø± ØªÙˆÚ©Ù† Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø¨Ø§Ø´Ø¯
    """
    try:
        payload = jwt.decode(
            token,
            settings.SECRET_KEY.get_secret_value(),
            algorithms=[settings.JWT_ALGORITHM]
        )
        return payload
    except JWTError as e:
        raise e


crud.py
# -*- coding: utf-8 -*-
"""
CRUD helpers for DastYarâ€‘eâ€¯SOT
"""

from __future__ import annotations
import os
import uuid
import logging
from datetime import date, datetime, timezone, timedelta
from typing import List, Optional

import docx
from sqlalchemy.exc import NoResultFound
from sqlalchemy.orm import Session

from app import models, auth
from app.core.config import settings
from app.core.file_manager import file_manager

logger = logging.getLogger(__name__)

# =============================================================================
# ğŸ•’ Helper
# =============================================================================
def _now_tehran() -> datetime:
    return datetime.now(timezone(timedelta(hours=3, minutes=30)))

# =============================================================================
# ğŸŸ¢ Ú©Ø§Ø±Ø¨Ø±Ø§Ù†
# =============================================================================
def get_user(db: Session, user_id: int) -> models.User | None:
    return db.query(models.User).filter(models.User.id == user_id).first()

def get_user_by_username(db: Session, username: str) -> models.User | None:
    return db.query(models.User).filter(models.User.username == username).first()

def get_users(
    db: Session,
    username_filter: str | None = None,
    skip: int = 0,
    limit: int = 100,
):
    q = db.query(models.User)
    if username_filter:
        q = q.filter(models.User.username.contains(username_filter))
    return q.order_by(models.User.id.desc()).offset(skip).limit(limit).all()

def create_user(db: Session, user_create) -> models.User:
    hashed_pw = auth.get_password_hash(user_create.password)
    db_user = models.User(
        username=user_create.username,
        hashed_password=hashed_pw,
        role=user_create.role,
        file_limit=user_create.file_limit,
        wallet_balance=user_create.wallet_balance,
        token_price=user_create.token_price,
    )
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    logger.info(f"User created: {db_user.username}")
    return db_user

def update_user_password(db: Session, user: models.User, new_plain_pw: str):
    user.hashed_password = auth.get_password_hash(new_plain_pw)
    db.commit()
    logger.info(f"Password updated for user: {user.username}")

def update_user_details(
    db: Session,
    user_to_update: models.User,
    username: str,
    file_limit: int,
    token_price: float,
):
    user_to_update.username = username
    user_to_update.file_limit = file_limit
    user_to_update.token_price = token_price
    db.commit()
    db.refresh(user_to_update)
    logger.info(f"User details updated: {user_to_update.username}")

# =============================================================================
# ğŸŸ¢ ØªØ±Ø§Ú©Ù†Ø´ Ùˆ Ú©ÛŒÙ Ù¾ÙˆÙ„
# =============================================================================
def create_transaction(
    db: Session,
    user_id: int,
    amount: float,
    description: str,
    token_price: Optional[float] = None,
):
    tx = models.Transaction(
        user_id=user_id,
        amount=amount,
        description=description,
        token_price_at_transaction=token_price,
        timestamp=_now_tehran(),
    )
    db.add(tx)
    logger.info(f"Transaction created for user {user_id}: {description}")
    return tx

def adjust_user_balance(db: Session, user: models.User, amount: float, description: str):
    if amount == 0:
        return
    user.wallet_balance += amount
    create_transaction(db, user.id, amount, description, user.token_price)
    db.commit()
    db.refresh(user)
    logger.info(f"Balance adjusted for {user.username}: {amount}")

def debit_from_wallet(db: Session, user: models.User, cost: float, description: str):
    db.refresh(user)
    if user.wallet_balance < cost:
        logger.warning(f"Insufficient balance for user {user.username}")
        raise ValueError("Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ù†Ø§Ú©Ø§ÙÛŒ Ø¨Ø±Ø§ÛŒ Ø§ÛŒÙ† Ø¹Ù…Ù„ÛŒØ§Øª")
    user.wallet_balance -= cost
    create_transaction(db, user.id, -cost, description, user.token_price)
    db.commit()
    db.refresh(user)
    logger.info(f"Debited {cost} from {user.username}")

# =============================================================================
# ğŸŸ¢ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ø±ÙˆÙ†ÙˆØ´Øª
# =============================================================================
def create_transcription_record(
    db: Session,
    filename: str,
    user_id: int,
    lang: str,
    original_filename: Optional[str] = None,
) -> models.TranscriptionFile:
    rec = models.TranscriptionFile(
        user_id=user_id,
        original_filename=original_filename or filename,
        display_filename=filename,
        language=lang,
        status="queued",
        timestamp=_now_tehran(),
    )
    db.add(rec)
    db.commit()
    db.refresh(rec)
    logger.info(f"Transcription record created: {rec.id}")
    return rec

def set_task_id(db: Session, record_id: int, task_id: str):
    rec = db.query(models.TranscriptionFile).get(record_id)
    if rec:
        rec.celery_task_id = task_id
        db.commit()
        logger.info(f"Task ID set for record {record_id}: {task_id}")

def update_transcription_status(db: Session, record_id: int, status: str):
    rec = db.query(models.TranscriptionFile).get(record_id)
    if rec:
        rec.status = status
        if status in ("completed", "failed", "canceled"):
            rec.finished_at = _now_tehran()
        db.commit()
        logger.info(f"Status updated for record {record_id}: {status}")

def finalize_job(
    db: Session,
    record: models.TranscriptionFile,
    final_text: str,
    duration: int,
):
    record.status = "completed"
    record.final_result_text = final_text
    record.processing_duration_seconds = duration

    base = f"{record.id}_{record.original_filename.rsplit('.', 1)[0]}"
    txt_name = f"{base}.txt"
    file_manager.save_file(final_text.encode('utf-8'), txt_name)
    record.output_filename_txt = txt_name

    doc = docx.Document()
    doc.add_paragraph(final_text)
    docx_name = f"{base}.docx"
    doc_path = file_manager.get_upload_path(docx_name)
    doc.save(doc_path)
    record.output_filename_docx = docx_name

    db.commit()
    logger.info(f"Job finalized: {record.id}")

def get_job(db: Session, job_id: int, owner: models.User):
    q = db.query(models.TranscriptionFile).filter_by(id=job_id)
    if owner.role != models.Role.admin:
        q = q.filter_by(user_id=owner.id)
    return q.first()

# =============================================================================
# ğŸŸ¢ Ú©ÙˆØ¦Ø±ÛŒâ€ŒÙ‡Ø§ÛŒ Ø±ÙˆÙ†ÙˆØ´Øª Ø¨Ø±Ø§ÛŒ ØµÙØ­Ø§Øª
# =============================================================================
def get_transcription(db: Session, record_id: int) -> models.TranscriptionFile | None:
    return db.query(models.TranscriptionFile).get(record_id)

def get_user_transcriptions(db: Session, user_id: int, skip: int = 0, limit: int = 15):
    return (
        db.query(models.TranscriptionFile)
        .filter(models.TranscriptionFile.user_id == user_id)
        .order_by(models.TranscriptionFile.timestamp.desc())
        .offset(skip)
        .limit(limit)
        .all()
    )

def get_user_transcriptions_count(db: Session, user_id: int) -> int:
    return db.query(models.TranscriptionFile).filter(models.TranscriptionFile.user_id == user_id).count()

def get_all_transcriptions(db: Session, skip: int = 0, limit: int = 15):
    return (
        db.query(models.TranscriptionFile)
        .order_by(models.TranscriptionFile.timestamp.desc())
        .offset(skip)
        .limit(limit)
        .all()
    )

def get_all_transcriptions_count(db: Session) -> int:
    return db.query(models.TranscriptionFile).count()

def get_transcriptions_by_ids(db: Session, user_id: int, job_ids: List[int]):
    return (
        db.query(models.TranscriptionFile)
        .filter(
            models.TranscriptionFile.id.in_(job_ids),
            models.TranscriptionFile.user_id == user_id,
        )
        .all()
    )

# =============================================================================
# ğŸŸ¢ ØªØ±Ø§Ú©Ù†Ø´â€ŒÙ‡Ø§ (Ú¯Ø²Ø§Ø±Ø´)
# =============================================================================
def get_user_transactions(db: Session, user_id: int, skip: int = 0, limit: int = 15):
    return (
        db.query(models.Transaction)
        .filter(models.Transaction.user_id == user_id)
        .order_by(models.Transaction.timestamp.desc())
        .offset(skip)
        .limit(limit)
        .all()
    )

def get_user_transactions_count(db: Session, user_id: int) -> int:
    return db.query(models.Transaction).filter(models.Transaction.user_id == user_id).count()

def get_all_transactions(
    db: Session,
    username_filter: str | None = None,
    skip: int = 0,
    limit: int = 15,
):
    q = db.query(models.Transaction).join(models.User)
    if username_filter:
        q = q.filter(models.User.username.contains(username_filter))
    return (
        q.order_by(models.Transaction.timestamp.desc())
        .offset(skip)
        .limit(limit)
        .all()
    )

def get_all_transactions_count(db: Session, username_filter: str | None = None) -> int:
    q = db.query(models.Transaction).join(models.User)
    if username_filter:
        q = q.filter(models.User.username.contains(username_filter))
    return q.count()

# =============================================================================
# ğŸŸ¢ Settings
# =============================================================================
def get_setting(db: Session, key: str):
    return db.query(models.Setting).filter(models.Setting.key == key).first()

def update_setting(db: Session, key: str, value: str):
    s = get_setting(db, key)
    if s:
        s.value = value
    else:
        s = models.Setting(key=key, value=value)
        db.add(s)
    db.commit()
    logger.info(f"Setting updated: {key}")

def upsert_setting(db: Session, key: str, value: str):
    try:
        setting = db.query(models.Setting).filter(models.Setting.key == key).one()
        setting.value = value
    except NoResultFound:
        setting = models.Setting(key=key, value=value)
        db.add(setting)
    db.commit()
    db.refresh(setting)
    logger.info(f"Setting upserted: {key}")
    return setting

# =============================================================================
# ğŸŸ¢ API KEY CRUD
# =============================================================================
def _generate_api_key() -> str:
    return uuid.uuid4().hex + uuid.uuid4().hex

def create_api_key(db: Session, user: models.User) -> models.APIKey:
    key = _generate_api_key()
    api_key = models.APIKey(key=key, owner=user)
    db.add(api_key)
    db.commit()
    db.refresh(api_key)
    logger.info(f"API key created for user: {user.username}")
    return api_key

def get_api_key(db: Session, key_str: str) -> Optional[models.APIKey]:
    return db.query(models.APIKey).filter(models.APIKey.key == key_str).first()

def get_api_key_by_user(db: Session, user: models.User) -> Optional[models.APIKey]:
    return (
        db.query(models.APIKey)
        .filter(models.APIKey.user_id == user.id, models.APIKey.is_active.is_(True))
        .first()
    )

def deactivate_api_key(db: Session, api_key: models.APIKey):
    api_key.is_active = False
    db.commit()
    logger.info(f"API key deactivated: {api_key.key}")

database.py
# app/database.py

from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

# --- Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø¯ÛŒØªØ§Ø¨ÛŒØ³ Ù…Ø­Ù„ÛŒ SQLite ---
# Ø§ÛŒÙ† Ø¢Ø¯Ø±Ø³ Ø¨Ù‡ Ø¨Ø±Ù†Ø§Ù…Ù‡ Ù…ÛŒâ€ŒÚ¯ÙˆÛŒØ¯ Ú©Ù‡ ÛŒÚ© ÙØ§ÛŒÙ„ Ø¨Ù‡ Ù†Ø§Ù… transcriber.db Ø¯Ø± Ø±ÛŒØ´Ù‡ Ù¾Ø±ÙˆÚ˜Ù‡ Ø§ÛŒØ¬Ø§Ø¯ Ú©Ù†Ø¯.
SQLALCHEMY_DATABASE_URL = "sqlite:///./transcriber.db"

# Ø³Ø§Ø®Øª Ù…ÙˆØªÙˆØ± SQLAlchemy Ø¨Ø±Ø§ÛŒ Ø§ØªØµØ§Ù„ Ø¨Ù‡ Ø¯ÛŒØªØ§Ø¨ÛŒØ³
# Ø¢Ø±Ú¯ÙˆÙ…Ø§Ù† connect_args Ø¨Ø±Ø§ÛŒ Ø³Ø§Ø²Ú¯Ø§Ø±ÛŒ Ø¨Ø§ SQLite Ø¶Ø±ÙˆØ±ÛŒ Ø§Ø³Øª
engine = create_engine(
    SQLALCHEMY_DATABASE_URL, connect_args={"check_same_thread": False}
)

# Ø³Ø§Ø®Øª ÛŒÚ© Ú©Ù„Ø§Ø³ Session Ø¨Ø±Ø§ÛŒ Ø§Ø±ØªØ¨Ø§Ø· Ø¨Ø§ Ø¯ÛŒØªØ§Ø¨ÛŒØ³ Ø¯Ø± Ù‡Ø± Ø¯Ø±Ø®ÙˆØ§Ø³Øª
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# Ø³Ø§Ø®Øª ÛŒÚ© Ú©Ù„Ø§Ø³ Ù¾Ø§ÛŒÙ‡ Ø¨Ø±Ø§ÛŒ ØªÙ…Ø§Ù… Ù…Ø¯Ù„â€ŒÙ‡Ø§ÛŒ Ø¯ÛŒØªØ§Ø¨ÛŒØ³
Base = declarative_base()

messages.py
# Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§ÛŒ Ø³ÛŒØ³ØªÙ…
INVALID_CREDENTIALS = "Ù†Ø§Ù… Ú©Ø§Ø±Ø¨Ø±ÛŒ ÛŒØ§ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø§Ø´ØªØ¨Ø§Ù‡ Ø§Ø³Øª"
PASSWORD_CHANGE_SUCCESS = "Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ØªØºÛŒÛŒØ± Ú©Ø±Ø¯"
PASSWORD_CHANGE_ERROR = "Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± ÙØ¹Ù„ÛŒ Ø§Ø´ØªØ¨Ø§Ù‡ Ø§Ø³Øª"
FILE_LIMIT_EXCEEDED = "Ù…Ø­Ø¯ÙˆØ¯ÛŒØª Ø±ÙˆØ²Ø§Ù†Ù‡ Ø´Ù…Ø§ Ú©Ø§ÙÛŒ Ù†ÛŒØ³Øª"
INVALID_FILE_TYPE = "ÙÙ‚Ø· ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ txt ÛŒØ§ docx Ù…Ø¬Ø§Ø²Ù†Ø¯"

celery_app.py
import os
from celery import Celery
from dotenv import load_dotenv
from app.core.config import settings

# Load environment variables
load_dotenv()

# Initialize Celery
celery_app = Celery(
    "dastyaresot",
    broker=settings.CELERY_BROKER_URL,
    backend=settings.CELERY_RESULT_BACKEND,
    include=[
        "app.tasks.audio",
        "app.tasks.text_tasks",
        "app.tasks.external_tasks"
    ]
)

# Default configuration
celery_app.conf.update(
    # Basic settings
    task_serializer="json",
    result_serializer="json",
    accept_content=["json"],
    timezone="Asia/Tehran",
    enable_utc=True,
    
    # Task routing
    task_default_queue="default",
    task_create_missing_queues=True,
    
    # Retry policy
    task_default_retry_delay=60,  # 1 minute
    task_max_retries=3,
    task_track_started=True,
    
    # Result expiration
    result_expires=24 * 3600,  # 1 day
    
    # Worker settings
    worker_prefetch_multiplier=1,
    worker_concurrency=4,
    worker_max_tasks_per_child=100,
    
    # Security
    worker_send_task_events=True,
    event_queue_expires=60,
    worker_proc_alive_timeout=30,
)

# Queue routing
celery_app.conf.task_routes = {
    "app.tasks.audio.*": {"queue": "audio"},
    "app.tasks.text_tasks.*": {"queue": "text"},
    "app.tasks.external_tasks.*": {"queue": "api"},
}

# Task-specific settings
celery_app.conf.task_annotations = {
    # Audio tasks
    "app.tasks.audio.parallel_audio_job": {
        "time_limit": 1800,  # 30 minutes
        "soft_time_limit": 1500,  # 25 minutes
        "max_retries": 5,
        "default_retry_delay": 120,  # 2 minutes
    },
    
    # Text processing tasks
    "app.tasks.text_tasks.background_text_correction_task": {
        "time_limit": 600,  # 10 minutes
        "max_retries": 3,
    },
    
    # External API tasks
    "app.tasks.external_tasks.enqueue_external_job": {
        "time_limit": 1200,  # 20 minutes
        "rate_limit": "10/m",  # 10 per minute
    }
}

# Periodic tasks (Beat schedule)
celery_app.conf.beat_schedule = {
    "cleanup_expired_sessions": {
        "task": "app.tasks.maintenance.cleanup_expired_sessions",
        "schedule": 3600,  # Every hour
        "options": {"queue": "maintenance"}
    },
    "update_daily_limits": {
        "task": "app.tasks.maintenance.reset_daily_limits",
        "schedule": 86400,  # Daily
        "options": {"queue": "maintenance"}
    }
}

if __name__ == "__main__":
    celery_app.start()


models.py
# -*- coding: utf-8 -*-
from __future__ import annotations

import enum
from datetime import datetime, date

import jdatetime
import pytz
from sqlalchemy import (
    Column,
    Date,
    DateTime,
    Enum,
    Float,
    ForeignKey,
    Integer,
    String,
    Text,
    Boolean,
)
from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.orm import relationship

from .database import Base


class Role(str, enum.Enum):
    admin = "admin"
    employee = "employee"
    customer = "customer"


class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    username = Column(String, unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=False)

    role = Column(Enum(Role), nullable=False, default=Role.customer)

    created_at = Column(DateTime, default=datetime.utcnow)

    file_limit = Column(Integer, default=5)
    daily_transcription_count = Column(Integer, default=0)
    last_transcription_date = Column(Date, nullable=True)

    wallet_balance = Column(Float, default=0.0)
    token_price = Column(Float, default=10.0)

    is_active = Column(Boolean, default=True)

    transcriptions = relationship("TranscriptionFile", back_populates="owner")
    transactions   = relationship("Transaction",        back_populates="user")
    api_keys       = relationship("APIKey",             back_populates="owner")


class TranscriptionFile(Base):
    __tablename__ = "transcriptions"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"))

    original_filename = Column(String, nullable=False)
    # â† Ø³ØªÙˆÙ† Ø¬Ø¯ÛŒØ¯ Ø¨Ø±Ø§ÛŒ Ù†Ø§Ù… Ù†Ù…Ø§ÛŒØ´ÛŒ Ø¯Ø± Ø¯Ø§Ø´Ø¨ÙˆØ±Ø¯
    display_filename  = Column(String, nullable=False)

    language = Column(String, nullable=False)

    timestamp = Column(DateTime, default=datetime.utcnow)
    status    = Column(String, default="pending")   # pending | queued | processing | completed | failed | canceled

    celery_task_id = Column(String(50), nullable=True, index=True)

    raw_result_text   = Column(Text, nullable=True)
    ai_result_text    = Column(Text, nullable=True)
    final_result_text = Column(Text, nullable=True)

    processing_duration_seconds = Column(Integer, nullable=True)
    ai_token_usage              = Column(Integer, nullable=True)

    output_filename_txt  = Column(String, nullable=True)
    output_filename_docx = Column(String, nullable=True)

    owner = relationship("User", back_populates="transcriptions")

    @hybrid_property
    def timestamp_local(self):
        utc_ts   = self.timestamp.replace(tzinfo=pytz.utc)
        local_tz = pytz.timezone("Asia/Tehran")
        return utc_ts.astimezone(local_tz)

    @hybrid_property
    def user(self):
        return self.owner


class Transaction(Base):
    __tablename__ = "transactions"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    amount = Column(Float, nullable=False)
    description = Column(String, nullable=False)

    timestamp = Column(DateTime, default=datetime.utcnow)
    token_price_at_transaction = Column(Float, nullable=True)

    user = relationship("User", back_populates="transactions")

    @hybrid_property
    def timestamp_shamsi(self):
        utc_ts   = self.timestamp.replace(tzinfo=pytz.utc)
        local_tz = pytz.timezone("Asia/Tehran")
        local_time = utc_ts.astimezone(local_tz)
        return jdatetime.datetime.fromgregorian(datetime=local_time)


class APIKey(Base):
    __tablename__ = "api_keys"

    id = Column(Integer, primary_key=True, index=True)
    key = Column(String, unique=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    created_at = Column(DateTime, default=datetime.utcnow)
    last_used_at = Column(DateTime, nullable=True)

    is_active = Column(Boolean, default=True)

    total_calls       = Column(Integer, default=0)
    total_tokens_used = Column(Integer, default=0)

    owner = relationship("User", back_populates="api_keys")


class Setting(Base):
    __tablename__ = "settings"

    key   = Column(String, primary_key=True)
    value = Column(String, nullable=False)



